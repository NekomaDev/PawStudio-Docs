{
    "/PawStudio-Docs/": {
        "title": "ğŸ“œ Welcome to LiteQuest",
        "text": "ğŸ“œ Welcome to LiteQuest LiteQuest is a lightweight and flexible Minecraft plugin for creating and managing quests. It is designed to work efficiently on any Paper-based server and offers both solo an LiteQuest  is a lightweight and flexible Minecraft plugin for creating and managing quests. It is designed to work efficiently on any Paper-based server and offers both solo and group questing experiences. ğŸ“Œ Key Features Quest-based configuration Each quest is stored as a separate configuration file ( 1 config = 1 quest ). All quest files are located in: plugins/LiteQuest/quests Solo or Group Play Quests can be assigned to one or multiple players, allowing cooperative progression. Optimized Data Loading Quest sessions and player data are loaded only when needed, ensuring high performance. Quest Sessions When a quest is assigned, a dedicated  session  is created: plugins/LiteQuest/sessions Each session stores live quest progress and participant information. Player Data Management Player profiles are stored in: plugins/LiteQuest/players Upon login, the plugin automatically loads the playerâ€™s profile along with all active quest sessions. Progress Tracking Players can view their active quests via: /lquest menu The menu displays all active quests and the completion percentage for each participant. Reward System Online players receive rewards immediately upon quest completion. Offline players have their rewards stored in their profile until their next login. ğŸ“‚ Data Structure Overview plugins/   LiteQuest/     quests/       <- Static quest configurations     sessions/     <- Active quest session data     players/      <- Player profiles"
    },
    "/PawStudio-Docs/documentation/litequest/quest-config/": {
        "title": " ğŸ“˜ Quest config",
        "text": "ğŸ“˜ Quest config Each file contains: Quest display settings (icon, name, description) Conditions (objectives to complete) Rewards (per-player ranking rewards) Start commands (executed when the quest begins) ğŸ“ Example â€“ Miner Quest (Static) JSON { \n   \"display_item\" : { \n     \"material\" :  \"IRON_PICKAXE\" , \n     \"display_name\" :  \"{#FFE04F}Miner quest!\" , \n     \"lore\" : [ \n       \"{#FFD966}Put your pickaxe to work and show your skills!\" , \n       \"{#FFD966}Mine various stones and gather valuable resources.\" , \n       \"{#FFD966}Complete all tasks to earn great rewards.\" \n     ] \n   }, \n   \"conditions\" : [ \n     { \n       \"display_tip\" :  \"{#FFE04F}Stone\" , \n       \"action\" :  \"BREAK\" , \n       \"target\" :  \"STONE\" , \n       \"amount\" :  \"3\" \n     }, \n     { \n       \"display_tip\" :  \"{#B1B3A5}Andesite\" , \n       \"action\" :  \"BREAK\" , \n       \"target\" :  \"ANDESITE\" , \n       \"amount\" :  \"3\" \n     } \n   ], \n   \"reward\" : { \n     \"start_commands\" :[ \n       \"server_message {#FF8C26}[LiteQuest] {#FF8C26}{#FFFB92}Miner quest has started! {#FF3939}Hurry up!!!\" \n     ], \n     \"rewards\" :{ \n       \"1\" :[ \n          \"plugin_message {#FFE04F}Miner quest {#7AFF5A}completed! \\n Â§7Reward: \\n  {#FFFC26}â‘ Money: {#FF9601}500$ \\n  {#7AFF5A}â‘ Exp: {#FF9601}250\" , \n          \"money add %player_name% 500\" , \n          \"experience add %player_name% 250\" \n       ], \n       \"2\" :[ \n         \"plugin_message {#FFE04F}Miner quest {#7AFF5A}completed! \\n Â§7Reward: \\n  {#FFFC26}â‘ Money: {#FF9601}250$ \\n  {#7AFF5A}â‘ Exp: {#FF9601}100\" , \n          \"money add %player_name% 250\" , \n          \"experience add %player_name% 100\" \n       ]  \n     } \n   } \n } ğŸ“‚ Configuration Section Description display_item Defines how the quest appears in menus. material Item icon for the quest. display_name Colored title of the quest. lore Multi-line description (supports color codes). conditions A list of objectives the player must complete. display_tip Short description shown in the quest progress. action Type of action required ( BREAK , KILL , etc.). target Minecraft material or entity to interact with. amount Quantity required to fulfill the condition. âš™ï¸ How Rewards Work Rewards are assigned  by position in contribution ranking . Example: The player who completes the largest percentage of the quest objectives gets reward  #1 , the second-most contributing player gets reward  #2 , and so on. Each reward set can contain: Chat messages  ( plugin_message ) Economy commands  ( money add ) Experience commands  ( experience add ) Any custom plugin commands ğŸ“¢ Notes Global Quests :  start_commands  can be used to send a server-wide notification when a global quest begins. Completion : In this example, players must break  3 Stone  and  3 Andesite  to finish the quest. Color Codes : The  {#HEXCODE}  format is supported for hex colors. Standard Minecraft  Â§  color codes can also be used. âš¡ Dynamic Quest Configuration Dynamic quests in  LiteQuest  allow  variable objectives  and  scalable rewards  based on each playerâ€™s performance. Unlike static quests, where objectives are fixed, dynamic quests use  randomized target amounts  and  per-unit rewards . ğŸ“ Example â€“ Miner Quest (Dynamic) JSON { \n   \"display_item\" : { \n     \"material\" :  \"IRON_PICKAXE\" , \n     \"display_name\" :  \"{#FFE04F}Miner quest!\" , \n     \"lore\" : [ \n       \"{#FFD966}Put your pickaxe to work and show your skills!\" , \n       \"{#FFD966}Mine various stones and gather valuable resources.\" , \n       \"{#FFD966}Complete all tasks to earn great rewards.\" \n     ] \n   }, \n   \"conditions\" : [ \n     { \n       \"display_tip\" :  \"{#B1B3A5}Stone\" , \n       \"action\" :  \"BREAK\" , \n       \"target\" :  \"STONE\" , \n       \"amount\" :  \"1-10\" , \n       \"reward_per_unit\" : { \n         \"money\" :  10 \n       } \n     }, \n     { \n       \"display_tip\" :  \"{#B1B3A5}Andesite\" , \n       \"action\" :  \"BREAK\" , \n       \"target\" :  \"ANDESITE\" , \n       \"amount\" :  \"1-10\" , \n       \"reward_per_unit\" : { \n         \"money\" :  10 , \n         \"exp\" :  5 \n       } \n     } \n   ], \n   \"reward\" : { \n     \"start_commands\" : [ \n       \"server_message {#FF8C26}[LiteQuest] {#FF8C26}{#FFFB92}Miner quest has started! {#FF3939}Hurry up!!!\" \n     ], \n     \"reward_commands\" : [ \n       \"plugin_message {#FFE04F}Miner quest {#7AFF5A}completed! \\n Â§7Reward: \\n  {#FFFC26}â‘ Money: {#FF9601}%money%$ \\n  {#7AFF5A}â‘ Exp: {#FF9601}%exp%\" , \n       \"money add %player_name% %money%\" , \n       \"experience add %player_name% %exp%\" \n     ], \n     \"reward_map\" : [ \n       \"1 100%\" , \n       \"2-5 50%\" , \n       \"5-10 25%\" \n     ] \n   } \n } ğŸ“‚ Configuration amount Random range for objective count (e.g.,  \"1-10\"  â†’ random between 1 and 10). reward_per_unit Reward values per unit of the objective completed. reward_commands Commands executed for  all ranked players , using calculated reward values. reward_map Determines  percentage of rewards  for each ranking group (e.g., rank 1 gets 100%, ranks 2â€“5 get 50%, ranks 5â€“10 get 25%). âš™ï¸ How Rewards Are Calculated Determine Objective Amount For each condition, a random number within  amount  range is chosen. Example:  1-10  â†’ the quest may require 7 Stone this time. Track Player Progress Every completed unit adds to the playerâ€™s reward calculation using  reward_per_unit . Calculate Base Rewards Total_Money = Units_Completed Ã— money_per_unit Total_Exp   = Units_Completed Ã— exp_per_unit Apply Ranking Modifiers Ranking is based on  percentage of total quest completion . Apply percentage from  reward_map  to each playerâ€™s  calculated rewards . ğŸ“¢ Notes Dynamic difficulty  makes each quest unique on every run. reward_per_unit  as placeholders : %money%  and  %exp%  are automatically replaced in  reward_commands  with the calculated totals after applying  reward_map . Flexible scaling  allows easy balancing of rewards for large player groups. ğŸ¯ Quest Event Actions Action Description BREAK Block break PLACE Block place SMELT Furnace smelt (todo) CRAFT Item craft KILL Entity kill TAME Entity tame MILK Milk entity SHEAR Shear entity BREED Breed entity"
    },
    "/PawStudio-Docs/documentation/litecooking/welcome-to-litecooking/": {
        "title": " ğŸ³ Welcome to LiteCooking",
        "text": "ğŸ³ Welcome to LiteCooking LiteCooking  is a flexible, minigame-based crafting framework built on top of  LiteCore . Designed for immersive and interactive item creation, it turns boring crafting into a step-by-step experience that feels alive â€” with animations, sounds, permissions, and full customization. ğŸ® Minigame-Based Crafting Pick a recipe â†’ follow clear instructions (e.g.  Add wheat ,  Pour water ,  Stir ) â†’ complete interactive minigames â†’ get the final item. Each recipe can include: Multiple steps with different actions Timing, input checking, animations Feedback effects (particles, sounds, etc.) Crafting is no longer a click â†’ done. It's a  process , and itâ€™s  fun ."
    },
    "/PawStudio-Docs/documentation/litecooking/crafting-stations/": {
        "title": " ğŸ§± Crafting Stations",
        "text": "ğŸ§± Crafting Stations ğŸ—ï¸ Crafting Stations Crafting stations are special blocks that allow players to access and use recipes. Each station is fully configurable and can represent anything â€” from an  anvil  to a  magic altar , a  cooking pot , or a  ritual circle . LiteCooking allows you to create  unlimited custom stations , each with their own visuals and recipe list. ğŸ“ Where They Are Stored Crafting station configurations are stored as JSON files in: plugins/LiteCooking/workstations/ Each file represents a single  station ID , based on the filename. Example:  steel_anvil.json  defines the station ID  steel_anvil . ğŸ§© JSON Structure JSON { \n   \"item\" : { \n     \"material\" :  \"ANVIL\" , \n     \"display_name\" :  \"{#C2C2C2}Steel anvil\" \n   }, \n   \"recipes\" : [ \n     \"steel_sword\" , \n     \"gold_sword\" \n   ], \n   \"work_animation\" :  \"anvil_working\" , \n   \"use_animation\" :  \"anvil_use\" , \n   \"item_slots\" : [ \n     \"0,0,0.2\" , \n     \"0,0,-0.2\" \n   ] \n } ğŸ§± Field Explanation To pick up a draggable item, press the space bar. While dragging, use the arrow keys to move the item. Press space again to drop the item in its new position, or press escape to cancel. To pick up a draggable item, press the space bar. While dragging, use the arrow keys to move the item. Press space again to drop the item in its new position, or press escape to cancel. Field Type Description item LiteItem The visual item that represents the station (used in GUI, interaction, etc.) recipes List<String> List of recipe IDs available from this station use_animation String ID of animation to play when the station is used work_animation String (Optional) Animation to play during crafting progress item_slots List<String> Offset position where the items will be placed ğŸ” Example:  steel_anvil.json JSON { \n   \"item\" : { \n     \"material\" :  \"ANVIL\" , \n     \"display_name\" :  \"{#C2C2C2}Steel anvil\" \n   }, \n   \"recipes\" : [ \n     \"steel_sword\" , \n     \"gold_sword\" \n   ], \n   \"work_animation\" :  \"anvil_working\" , \n   \"use_animation\" :  \"anvil_use\" , \n   \"item_slots\" : [ \n     \"0,0,0.2\" , \n     \"0,0,-0.2\" \n   ] \n } This defines a station called  steel_anvil : Appears as an  Anvil  with a custom display name Allows crafting  steel_sword  and  gold_sword  recipes Plays the animation  anvil_use  when interacted with ğŸ’¡ How to Use in Game Stations are normally placed or triggered in-game by the plugin logic. Each station is linked to recipes by ID â€” players will only see the recipes listed in the  recipes  array. You can have multiple stations for different professions or gameplay styles. âœ¨ Additional Features You can use  custom_model_data  to display unique station blocks in GUIs Use  work_animation  for visual feedback during crafting (e.g. glowing, smoke, etc.) Combine with  permission  checks in recipes for role-based crafting systems âœ… Summary Each  .json  in  workstations/  defines a  station ID Use  item  to define its appearance Assign multiple recipes via the  recipes  list Add  use_animation  and  work_animation  for full feedback Modular and fully customizable"
    },
    "/PawStudio-Docs/documentation/litecooking/recipes/": {
        "title": "ğŸ“˜ Recipes",
        "text": "ğŸ“˜ Recipes In LiteCooking, recipes define how a custom crafting process works â€” from input ingredients to step-by-step actions, to the final reward. Recipes are stored in the folder: plugins/LiteCooking/recipes_config/ Each recipe is a standalone  .json  file that can be written or generated manually. ğŸ§© Recipe Structure Each recipe contains: Title Title Title permission String (Optional) Required permission to access this recipe display_item LiteItem Icon shown in the GUI for this recipe reward_message String Message shown upon successful completion rewards List<LiteItem> Items given to the player as output stages List<RecipeStage> Sequence of crafting steps ğŸ” Stages A  stage  represents a  single crafting action  the player must complete (e.g. add ingredient, stir, pour, etc.). Each stage contains an  items  array â€” but  only one of those items will be chosen randomly  at runtime. This prevents automation and adds unpredictability to the crafting process. JSON \"stages\" : [ \n   { \n     \"items\" : [  ...  ]  // one will be picked randomly \n   }, \n   ... \n ] Think of it like: â€œin this step, add one of the following â€” but you donâ€™t know which one until the process starts.â€ ğŸ”§ RecipeItem Fields Each object in  items  is a  RecipeItem  with the following structure: Field Type Description item LiteItem The required item to use during this step mini_game MiniGameConfig The minigame to complete for this action tooltip String Tooltip shown in the GUI for this step animation String Animation ID to play on success time int Delay before the step becomes available (in ticks) reload_time int Cooldown after a failed attempt reload_tooltip String Message shown during reload ğŸ§ª Example Recipe JSON { \n   \"permission\" :  \"litecooking.recipe.steel_sword\" , \n   \"stages\" : [ \n     { \n       \"items\" : [ \n         { \n           \"item\" : { \n             \"material\" :  \"IRON_INGOT\" \n           }, \n           \"tooltip\" :  \"%time% \\n {#C2C2C2}Add iron\" , \n           \"time\" :  30 , \n           \"reload_time\" :  0 \n         } \n       ] \n     }, \n     { \n       \"items\" : [ \n         { \n           \"item\" : { \n             \"material\" :  \"IRON_INGOT\" \n           }, \n           \"tooltip\" :  \"%time% \\n {#C2C2C2}Add iron\" , \n           \"time\" :  30 , \n           \"reload_time\" :  0 \n         } \n       ] \n     }, \n     { \n       \"items\" : [ \n         { \n           \"mini_game\" : { \n             \"type\" :  \"base\" , \n             \"size\" :  10 , \n             \"speed\" :  5 , \n             \"health\" :  3 , \n             \"target_score\" :  3 , \n             \"animation_fail\" :  \"fail\" , \n             \"animation_use\" :  \"anvil_use\" \n           }, \n           \"tooltip\" :  \"%time% \\n {#FFED8D}Forge the steel!\" , \n           \"time\" :  30 , \n           \"reload_time\" :  0 \n         } \n       ] \n     }, \n     { \n       \"items\" : [ \n         { \n           \"item\" : { \n             \"material\" :  \"STICK\" \n           }, \n           \"tooltip\" :  \"%time% \\n {#C2C2C2}Add stick\" , \n           \"time\" :  30 , \n           \"reload_time\" :  5 , \n           \"reload_tooltip\" :  \"%time% \\n {#C2C2C2}The sword is tempered...\" , \n           \"animation\" :  \"stick_use\" \n         } \n       ] \n     } \n   ], \n   \"rewards\" : [ \n     { \n       \"material\" :  \"IRON_SWORD\" , \n       \"display_name\" :  \"{#C2C2C2}Steel sword\" \n     } \n   ], \n   \"reward_message\" :  \"{#C2C2C2}The Steel sword is ready\" \n } In this example: The player sees a stage with the tooltip \"Add a vegetable\" Either a carrot  or  a potato will be required (chosen randomly) The player doesnâ€™t know which until the moment arrives After success, the defined reward is granted ğŸ›¡ï¸ Why Use Randomized Inputs? This system: Prevents macro scripts and automation Keeps gameplay dynamic Allows multiple recipe variants using shared logic You can even create stages that mix different mini-games and items for added variety. âœ… Summary Each recipe is a sequence of  stages  (one per step) Each stage randomly selects  one item  from its  items  list This makes recipes  non-deterministic  and harder to script Every step can have a mini-game, tooltip, cooldown, animation, and delay Rewards and messages are fully configurable ğŸ—¡ï¸ Example Recipe: Steel Sword This is a full working example of a multi-stage recipe that guides the player through crafting a  Steel Sword  using step-by-step interactions and a forging minigame. JSON { \n   \"permission\" :  \"litecooking.recipe.steel_sword\" , \n   \"stages\" : [ \n     { \n       \"items\" : [ \n         { \n           \"item\" : { \n             \"material\" :  \"IRON_INGOT\" \n           }, \n           \"tooltip\" :  \"%time% \\n {#C2C2C2}Add iron\" , \n           \"time\" :  30 , \n           \"reload_time\" :  0 \n         } \n       ] \n     }, \n     { \n       \"items\" : [ \n         { \n           \"item\" : { \n             \"material\" :  \"IRON_INGOT\" \n           }, \n           \"tooltip\" :  \"%time% \\n {#C2C2C2}Add iron\" , \n           \"time\" :  30 , \n           \"reload_time\" :  0 \n         } \n       ] \n     }, \n     { \n       \"items\" : [ \n         { \n           \"mini_game\" : { \n             \"type\" :  \"base\" , \n             \"size\" :  10 , \n             \"speed\" :  5 , \n             \"health\" :  3 , \n             \"target_score\" :  3 , \n             \"animation_fail\" :  \"fail\" , \n             \"animation_use\" :  \"anvil_use\" \n           }, \n           \"tooltip\" :  \"%time% \\n {#FFED8D}Forge the steel!\" , \n           \"time\" :  30 , \n           \"reload_time\" :  0 \n         } \n       ] \n     }, \n     { \n       \"items\" : [ \n         { \n           \"item\" : { \n             \"material\" :  \"STICK\" \n           }, \n           \"tooltip\" :  \"%time% \\n {#C2C2C2}Add stick\" , \n           \"time\" :  30 , \n           \"reload_time\" :  5 , \n           \"reload_tooltip\" :  \"%time% \\n {#C2C2C2}The sword is tempered...\" , \n           \"animation\" :  \"stick_use\" \n         } \n       ] \n     } \n   ], \n   \"rewards\" : [ \n     { \n       \"material\" :  \"IRON_SWORD\" , \n       \"display_name\" :  \"{#C2C2C2}Steel sword\" \n     } \n   ], \n   \"reward_message\" :  \"{#C2C2C2}The Steel sword is ready\" \n } ğŸ” Breakdown of Each Stage ğŸ”¨ Stage 1 & 2 â€” Add Iron \"material\": \"IRON_INGOT\" The player must add an iron ingot. Tooltip:  Add iron Time:  30 ticks  (1.5 seconds) No cooldown or reload. This step is repeated twice to simulate stacking ingots. ğŸ§ª Stage 3 â€” Forge Steel (Minigame) JSON \"mini_game\" : { \n   \"type\" :  \"base\" , \n   \"size\" :  10 , \n   \"speed\" :  5 , \n   \"health\" :  3 , \n   \"target_score\" :  3 , \n   \"animation_fail\" :  \"fail\" , \n   \"animation_use\" :  \"anvil_use\" \n } A forging minigame must be completed. The player must score 3 hits without losing all 3 health points. Tooltip:  Forge the steel! anvil_use  animation plays on success,  fail  on mistake. ğŸªµ Stage 4 â€” Add Stick (Handle) \"material\": \"STICK\" The player must add a stick. Tooltip:  Add stick Cooldown:  5 ticks  (0.25 seconds) with custom reload tooltip Animation:  stick_use  when successful ğŸ Final Reward JSON { \n   \"material\" :  \"IRON_SWORD\" , \n   \"display_name\" :  \"{#C2C2C2}Steel sword\" \n } The player receives a renamed iron sword. Reward message shown in chat: The Steel sword is ready ğŸ§  Why It Works Step-by-step interaction keeps the process immersive. Minigame adds player engagement and skill. Cooldowns prevent spam-clicking or scripting. Tooltips and animations improve feedback. The recipe is fully customizable and expandable."
    },
    "/PawStudio-Docs/documentation/liteco/welcome/": {
        "title": "ğŸ‘‹Welcome",
        "text": "ğŸ‘‹Welcome to LiteCore LiteCore v2  is the shared core library used across all plugins developed by  PawStudio . It serves as the foundation for plugin logic, utilities, and infrastructure. Originally built for  LiteCooking , LiteCore is now being gradually integrated into all of our plugin projects for maximum consistency and code reuse. ğŸ“ Core Directory Structure LiteCore provides several key directories that are automatically loaded and available to all plugins using it: ğŸ“‚  core/animations Contains all custom  animation files  used by the plugin. Each  .json  file defines an animation ID that can include sounds and particles triggered during gameplay. Example:  use_animation.json  â†’ usable as  animation: use_animation ğŸ“‚  core/gui Stores all  custom GUI pages  and interface layouts for the plugin. These files define button positions, titles, actions, and interaction behavior using a consistent format. Useful for modular menu building without code duplication. ğŸ“‚  core/translations Holds all  language files  for plugin localization. Each file contains key-value translation pairs used for messages, tooltips, UI text, etc. Supports easy multilingual support and custom language overrides. If you're a developer using one of our plugins or want to understand the shared logic powering our ecosystem â€” this documentation will guide you through the components and usage of  LiteCore v2 ."
    },
    "/PawStudio-Docs/documentation/liteco/liteitem/": {
        "title": "ğŸ“¦LiteItem",
        "text": "ğŸ“¦LiteItem LiteItem  is a simple JSON-based data model used to describe Minecraft items inside plugins powered by  LiteCore . It allows you to define item properties such as material, display name, lore, custom model data, NBT tags, and more â€” in a clean and readable format. You can use it to both create items and recognize them during plugin logic. ğŸ› ï¸ How to get LiteItem data Hold the item in your hand. Run the command: /[your_plugin] core data The plugin will print a LiteItem model based on the held item â€” you can copy it and use it in your configs. ğŸ“˜ LiteItem Structure There are  two formats  for LiteItem: 1. Full NBT Encoded Stores the complete internal NBT data of the item: JSON { \n   \"lite_item\" : { \n     \"amount\" :  1 , \n     \"data\" :  \"rO0ABXNyABp...\" \n   } \n } This method is exact but not editable by hand. 2. Readable JSON Format Easier to modify manually and recommended when you only care about certain properties: JSON { \n   \"lite_item\" : { \n     \"amount\" :  64 , \n     \"material\" :  \"OAK_LOG\" , \n     \"display_name\" :  \"Â§aMy log\" , \n     \"lore\" : [ \n       \"Hello!\" , \n       \"This is my log =)\" \n     ], \n     \"head_url\" :  \"f2f52f927efffd...\" , \n     \"custom_model_data\" :  \"1001\" , \n     \"compare\" :  \"material,display_name,custom_model_data\" , \n     \"use_sounds\" : [ \n       \"ENTITY_SHEEP_SHEAR\" , \n       \"ENTITY_SHEEP_SHEAR:0.5:2\" \n     ], \n     \"damage\" :  10 , \n     \"nbt\" : { \n       \"plugin_name:log_key\" :  \"oak_log\" \n     } \n   } \n } ğŸ” Field Explanation Field Description amount Amount of the item material Item material (e.g.  \"DIAMOND_SWORD\" ) display_name Colored name of the item ( Â§  codes supported) lore List of lore lines custom_model_data Model ID used for resource pack texture binding head_url Base64 texture hash (for heads) nbt Custom NBT tags stored in the item use_sounds Sounds to play when using this item. Format:  \"SOUND\"  or  \"SOUND:volume:pitch\" damage Can represent either item damage or amount consumed; supports random range  \"1-5\" compare Comma-separated list of fields used to identify the item (see below) ğŸ§  Understanding  compare Sometimes players might rename or slightly modify items. To prevent this from breaking plugin logic, you can specify which fields should be used when comparing items. Example: JSON { \n   \"lite_item\" : { \n     \"material\" :  \"OAK_LOG\" , \n     \"display_name\" :  \"Â§aMy log\" , \n     \"custom_model_data\" :  \"1001\" , \n     \"compare\" :  \"material,display_name,custom_model_data\" \n   } \n } If a player renames the item, and  display_name  is part of  compare , the item will no longer match. To make it more tolerant, reduce the comparison to non-editable fields: \"compare\": \"custom_model_data\" Now, the plugin identifies any item with the same  custom_model_data , regardless of name or damage. ğŸ¯ Usage Example Say you create a seed item via GUI: JSON { \n   \"seed_item\" : { \n     \"amount\" :  1 , \n     \"material\" :  \"WHEAT_SEEDS\" , \n     \"display_name\" :  \"Â§fãƒˆãƒãƒˆã®ç¨®\" , \n     \"custom_model_data\" :  \"10009\" \n   } \n } To avoid mismatches if the player renames the item, limit the comparison: JSON { \n   \"seed_item\" :  { \n     \"amount\" :  1, \n     \"material\" :  \"WHEAT_SEEDS\", \n     \"display_name\" :  \"Â§fãƒˆãƒãƒˆã®ç¨®\", \n     \"custom_model_data\" :  \"10009\", \n     \"compare\" :  \"custom_model_data\" \n   } \n } This way, only the model ID is used for recognition."
    },
    "/PawStudio-Docs/documentation/liteco/animations/": {
        "title": "ğŸ“· Animations",
        "text": "ğŸ“· Animations Animations  in LiteCore are configurable visual/audio effects that can be triggered by your plugins during specific actions (e.g. using an item, interacting with a block, completing a task, etc). Each animation is defined in a separate  .json  file and can include  sounds ,  particles , or both. ğŸ“ File Structure All animation files are stored in: plugins/LitePlugin/core/animations/ Each file represents a single animation and uses its filename (without  .json ) as the  animation ID . Example: A file named  use_animation.json  defines the animation with ID  use_animation , which can be triggered in plugin configs like so: animation: use_animation ğŸ§¾ Animation JSON Format Here's a minimal example of an animation config: JSON { \n   \"lite_sound\" :  { \n     \"sound\" :  \"ENTITY_ITEM_PICKUP\", \n     \"pitch\" :  1.0, \n     \"volume\" :  1.0 \n   }, \n   \"lite_particle\" :  { \n     \"particle\" :  \"COMPOSTER\", \n     \"amount\" :  10, \n     \"range\" :  0.2 \n   } \n }"
    }
}